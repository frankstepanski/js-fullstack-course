# Typed User Dashboard 

This project is an intentionally simple TypeScript application designed to teach the core ideas of TypeScript without adding extra complexity.

There is **no UI**, no browser, and no React in this project.

That is on purpose.

The goal is to understand **what TypeScript is**, **why it exists**, and **how it helps JavaScript developers**, before introducing frameworks.

## What This App Is

### What this app *is*

- A **command-line program** that runs with Node
- Written in **TypeScript**, compiled to JavaScript
- Focused on **data shapes, function contracts, and safety**
- A teaching tool to show how TypeScript helps *before* code runs

When you run the app, it simply logs information to the terminal.

### What this app is *not*

- ❌ Not a web app
- ❌ Not a React app
- ❌ Not a production-ready architecture
- ❌ Not using modern bundlers (Vite, Webpack, etc.)

This project is intentionally small and boring so that **TypeScript itself is the star**.

## Why TypeScript Exists 

JavaScript allows almost anything to run, even when the code is wrong. As applications grow, this leads to bugs that only appear at runtime, risky refactors, and unclear assumptions between developers.

TypeScript adds a **development-time layer** on top of JavaScript that lets you *describe your intent*. It checks your code **before it runs**, catches common mistakes early, and then disappears entirely when the app is built.

## How This Project Uses TypeScript

### High-level flow

1. You write TypeScript (`.ts` files)
2. TypeScript checks your code for mistakes
3. TypeScript compiles the code into JavaScript
4. Node runs the JavaScript

Important:
> **Node never runs TypeScript.**

TypeScript exists only to help developers while writing code.

## Project Structure

```txt
typed-user-dashboard/
├── src/        # TypeScript source files (what you write)
├── dist/       # Compiled JavaScript (what Node runs)
├── tsconfig.json
├── package.json
└── README.md
```

## Why the `src` Folder Exists

The `src` folder contains **all of the TypeScript you write**.

Keeping source code separate from compiled output helps:
- keep projects organized
- avoid mixing TypeScript and JavaScript
- make builds predictable

You should think of `src` as:
> “Code for humans to read and write.”


## Why the `dist` Folder Exists

The `dist` folder contains **plain JavaScript** generated by the TypeScript compiler.

This is the code that:
- Node actually runs
- would be deployed in a real application

You should think of `dist` as:
> “Code for machines to execute.”

You never edit files in `dist` directly. They are **generated**.


## Why TypeScript Must Be Compiled

Browsers and Node do **not** understand TypeScript syntax:

```ts
function greet(name: string): string {
  return `Hello, ${name}`;
}
```

Before this can run, TypeScript removes the types and outputs JavaScript:

```js
function greet(name) {
  return `Hello, ${name}`;
}
```

This is why we must compile TypeScript before running it.

## `tsconfig.json` — The TypeScript Rulebook

`tsconfig.json` tells TypeScript **how to behave**.

Key ideas:
- what JavaScript version to output
- where source files live
- where compiled files go
- how strict the type checking should be

In this project, we use strict settings so that TypeScript catches more mistakes early.

## File-by-File Explanation

### `src/types.ts` — Describing Data Shapes

This file defines **types** that describe what our data looks like.

```ts
export type User = {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
  loginCount: number;
};
```

Why this matters:
- JavaScript cannot describe object shapes
- TypeScript makes expectations explicit
- mistakes are caught before runtime

Types act as both **documentation** and **enforcement**.

---

### `src/users.ts` — Mock Data with Safety

This file simulates data you might receive from an API.

```ts
export const users: User[] = [ ... ];
```

Why this helps:
- TypeScript checks that every user is valid
- missing or incorrect properties are flagged immediately
- you gain confidence in downstream code

---

### `src/utils.ts` — Business Logic with Guarantees

This file contains functions that operate on users.

```ts
export function getAccountStatus(user: User): AccountStatus { ... }
```

TypeScript enforces:
- the function only accepts valid users
- the return value is predictable
- no accidental `undefined` or typo bugs

This makes refactoring safer and intent clearer.

---

### `src/index.ts` — Application Entry Point

This file wires everything together.

It:
- imports users
- calls utility functions
- logs output

TypeScript ensures that all pieces fit together correctly *before* the app runs.

## Why This Project Uses ES Modules

This project compiles TypeScript to **ES Modules** so it aligns with how **modern Node.js** and frontend tooling work today.

ES Modules are now the standard module system across:
- modern Node.js
- browsers
- bundlers like Vite
- frameworks like React and Next.js

Using ES Modules here keeps the mental model consistent as you move between backend and frontend projects.

This choice is intentional:
- it matches modern JavaScript standards
- it avoids switching module systems later
- it prepares you for real-world tooling
- it keeps the focus on TypeScript fundamentals

Node supports ES Modules natively, so no bundler is required for this project.

## How to Run the Project

This project is run using **npm scripts** defined in `package.json`, which is how most real-world Node.js projects are executed.

```bash
npm start
```

What happens step by step:

1. `npm start` first runs the TypeScript compiler (`tsc`)
2. TypeScript checks your code and reports any errors **during development**
3. All type annotations are removed
4. JavaScript files using ES Module syntax are emitted into the `dist/` folder
5. Node runs the compiled JavaScript from `dist/index.js`

Node never sees TypeScript — only JavaScript.

Although this project uses a single command for convenience, it is important to understand that **build** and **run** are still two distinct phases. TypeScript always runs *before* Node, and only JavaScript is ever executed at runtime.