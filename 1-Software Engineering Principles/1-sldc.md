#  Software Development Life Cycle (SDLC)

The **Software Development Life Cycle (SDLC)** is like a **roadmap** that guides how software is created ‚Äî from the very first idea üí° to the time it‚Äôs used, improved, and maintained over the years.  
It ensures teams don‚Äôt skip steps, waste time, or forget important details.

You can think of it like **building a house**:
- You first plan the design 
- Then gather materials  
- Build the structure  
- Inspect it  
- Move in  
- And keep fixing or upgrading things over time

## The Six Main Phases of the SDLC

### 1. **Planning**
 *"What do we want to build ‚Äî and why?"*

In this phase, the goal is to **define the project‚Äôs purpose** and **decide if it‚Äôs worth doing**.

**Key activities:**
- Identify the **problem** the software will solve  
- Determine **who will use it** (the users)  
- Estimate **time, cost, and resources** needed  
- Create a **high-level timeline**

**Example:**  
A school wants a web app for students to check grades online. The planning phase would involve discussing who will use it (students, teachers, parents) and what features are needed (login, grades, attendance, etc.).

 *Outcome:* A clear project plan or ‚Äúblueprint‚Äù for the software.


### 2. **Analysis (or Requirements Gathering)**
*"What exactly should the software do?"*

Here, the team gathers **detailed requirements** ‚Äî all the features, rules, and expectations.

**Key activities:**
- Interview users and stakeholders  
- Write down **functional requirements** (what it must do) and **non-functional requirements** (performance, security, etc.)  
- Identify constraints or limitations

**Example:**  
- Functional: Students can log in and see grades  
- Non-functional: The system should load in less than 3 seconds

 *Outcome:* A **Requirements Document** describing everything the system must do.

### 3. **Design**
 *"How will the software look and work?"*

Now the team decides **how the system will be built** ‚Äî the structure, the technology, and the interface.

**Key activities:**
- Create **system architecture** (how parts connect)  
- Design **databases** and **user interfaces (UIs)**  
- Choose **tools and frameworks** (like React, Node.js, etc.)  
- Make **mockups** or **wireframes**

**Example:**  
A designer creates a prototype of the ‚Äústudent dashboard‚Äù showing where buttons and grade tables will go.

 *Outcome:* Detailed **design documents and diagrams** ready for developers to build from.

---

### 4. **Development (Implementation)**
 *"Let‚Äôs build it!"*

This is when developers **write the actual code** to turn the design into a working product.

**Key activities:**
- Front-end developers create the **user interface** (what users see)  
- Back-end developers build the **server logic and databases**  
- Code is tested locally and reviewed by peers

**Example:**  
Developers use React to build the web app‚Äôs front end, and Node.js for the back end to connect to the database.

 *Outcome:* A functioning version of the software (the ‚Äúfirst draft‚Äù).

### 5. **Testing**
 *"Does it actually work?"*

Before releasing it, testers check if the software works **as expected** and **fix any bugs**.

**Key activities:**
- Run **unit tests** (small parts)  
- Do **integration tests** (parts working together)  
- Perform **user acceptance testing (UAT)** ‚Äî real users try it  
- Log and fix errors

**Example:**  
A tester logs in as a student, checks if grades show correctly, and reports any glitches.

 *Outcome:* A **stable, reliable version** ready to launch.

### 6. **Deployment & Maintenance**
 *"Let‚Äôs launch ‚Äî and keep improving it!"*

Once testing is complete, the software goes **live** so users can access it.  
Then, developers continue to **monitor, fix, and update** it as needed.

**Key activities:**
- Deploy the app to servers or app stores  
- Fix bugs users find  
- Release updates and new features  
- Maintain servers and security

**Example:**  
The grade portal is launched for all students.  
Later, updates add attendance reports and push notifications.

 *Outcome:* Real users are using the software ‚Äî and it keeps improving over time.


##  Why SDLC Matters

| Benefit | Description |
|----------|--------------|
| **Clarity** | Everyone knows what to do at each step |
| **Quality** | Early planning and testing reduce costly errors |
| **Predictability** | Easier to estimate costs, time, and resources |
| **Improvement** | Regular updates and feedback loops keep the product useful |

##  Summary

| Phase | Main Question | Output |
| --- | --- | --- |
| Planning | Why are we building this? For whom? | Vision, goals, constraints |
| Requirements | What must it do? How well? | User stories, requirements list |
| Design | How will it work? | Architecture, wireframes |
| Development | How do we build it? | Working code, commits |
| Testing | Does it work correctly? | Test reports, bug fixes |
| Deployment & Maintenance | How do we deliver and improve it? | Live app, updates, monitoring |

---


## üéØ Mini Project: Apply the SDLC

Pick a small app idea ‚Äî like **Flashcards**, **To-Do List**, or **Habit Tracker** ‚Äî and walk through all six phases:

1. **Planning:** Write a short problem statement.  
2. **Requirements:** List 6‚Äì10 user stories.  
3. **Design:** Create a simple diagram or UI sketch.  
4. **Development:** Build a small feature.  
5. **Testing:** Check if it works as expected.  
6. **Deployment:** Publish your demo link and note your next steps.